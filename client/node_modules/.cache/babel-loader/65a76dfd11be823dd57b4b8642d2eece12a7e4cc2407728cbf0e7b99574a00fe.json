{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\".concat(baseComponentName);\n}\n/**\r\n * We use class to make it easier to detect in heap snapshots by name\r\n */\nvar ObjectToBeRetainedByReact = /** @class */function () {\n  function ObjectToBeRetainedByReact() {}\n  return ObjectToBeRetainedByReact;\n}();\nfunction objectToBeRetainedByReactFactory() {\n  return new ObjectToBeRetainedByReact();\n}\nexport function useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n  var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1),\n    objectRetainedByReact = _a[0];\n  // Force update, see #2982\n  var _b = __read(React.useState(), 2),\n    setState = _b[1];\n  var forceUpdate = function () {\n    return setState([]);\n  };\n  // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n  var reactionTrackingRef = React.useRef(null);\n  if (!reactionTrackingRef.current) {\n    // First render for this component (or first time since a previous\n    // reaction from an abandoned render was disposed).\n    var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (trackingData_1.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.\n        trackingData_1.changedBeforeMount = true;\n      }\n    });\n    var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n  }\n  var reaction = reactionTrackingRef.current.reaction;\n  React.useDebugValue(reaction, printDebugValue);\n  React.useEffect(function () {\n    // Called on first mount only\n    recordReactionAsCommitted(reactionTrackingRef);\n    if (reactionTrackingRef.current) {\n      // Great. We've already got our reaction from our render;\n      // all we need to do is to record that it's now mounted,\n      // to allow future observable changes to trigger re-renders\n      reactionTrackingRef.current.mounted = true;\n      // Got a change before first mount, force an update\n      if (reactionTrackingRef.current.changedBeforeMount) {\n        reactionTrackingRef.current.changedBeforeMount = false;\n        forceUpdate();\n      }\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This can be due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up\n      // Re-create the reaction\n      reactionTrackingRef.current = {\n        reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n          // We've definitely already been mounted at this point\n          forceUpdate();\n        }),\n        mounted: true,\n        changedBeforeMount: false,\n        cleanAt: Infinity\n      };\n      forceUpdate();\n    }\n    return function () {\n      reactionTrackingRef.current.reaction.dispose();\n      reactionTrackingRef.current = null;\n    };\n  }, []);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var rendering;\n  var exception;\n  reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}","map":{"version":3,"mappings":"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","names":["Reaction","React","printDebugValue","addReactionToTrack","recordReactionAsCommitted","isUsingStaticRendering","observerComponentNameFor","baseComponentName","objectToBeRetainedByReactFactory","ObjectToBeRetainedByReact","useObserver","fn","useState","objectRetainedByReact","setState","forceUpdate","reactionTrackingRef","useRef","current","newReaction","trackingData_1","mounted","changedBeforeMount","useDebugValue","reaction","useEffect","cleanAt","Infinity","dispose","rendering","exception","track","e"],"sources":["D:\\заказы\\onepro\\onepro\\client\\node_modules\\mobx-react-lite\\src\\useObserver.ts"],"sourcesContent":["import { Reaction } from \"mobx\"\r\nimport React from \"react\"\r\nimport { printDebugValue } from \"./utils/printDebugValue\"\r\nimport {\r\n    addReactionToTrack,\r\n    IReactionTracking,\r\n    recordReactionAsCommitted\r\n} from \"./utils/reactionCleanupTracking\"\r\nimport { isUsingStaticRendering } from \"./staticRendering\"\r\n\r\nfunction observerComponentNameFor(baseComponentName: string) {\r\n    return `observer${baseComponentName}`\r\n}\r\n\r\n/**\r\n * We use class to make it easier to detect in heap snapshots by name\r\n */\r\nclass ObjectToBeRetainedByReact {}\r\n\r\nfunction objectToBeRetainedByReactFactory() {\r\n    return new ObjectToBeRetainedByReact()\r\n}\r\n\r\nexport function useObserver<T>(fn: () => T, baseComponentName: string = \"observed\"): T {\r\n    if (isUsingStaticRendering()) {\r\n        return fn()\r\n    }\r\n\r\n    const [objectRetainedByReact] = React.useState(objectToBeRetainedByReactFactory)\r\n    // Force update, see #2982\r\n    const [, setState] = React.useState()\r\n    const forceUpdate = () => setState([] as any)\r\n\r\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\r\n    // rendered and abandoned multiple times, so we need to track leaked\r\n    // Reactions.\r\n    const reactionTrackingRef = React.useRef<IReactionTracking | null>(null)\r\n\r\n    if (!reactionTrackingRef.current) {\r\n        // First render for this component (or first time since a previous\r\n        // reaction from an abandoned render was disposed).\r\n\r\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n            // Observable has changed, meaning we want to re-render\r\n            // BUT if we're a component that hasn't yet got to the useEffect()\r\n            // stage, we might be a component that _started_ to render, but\r\n            // got dropped, and we don't want to make state changes then.\r\n            // (It triggers warnings in StrictMode, for a start.)\r\n            if (trackingData.mounted) {\r\n                // We have reached useEffect(), so we're mounted, and can trigger an update\r\n                forceUpdate()\r\n            } else {\r\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\r\n                // when (and if) useEffect() arrives.\r\n                trackingData.changedBeforeMount = true\r\n            }\r\n        })\r\n\r\n        const trackingData = addReactionToTrack(\r\n            reactionTrackingRef,\r\n            newReaction,\r\n            objectRetainedByReact\r\n        )\r\n    }\r\n\r\n    const { reaction } = reactionTrackingRef.current!\r\n    React.useDebugValue(reaction, printDebugValue)\r\n\r\n    React.useEffect(() => {\r\n        // Called on first mount only\r\n        recordReactionAsCommitted(reactionTrackingRef)\r\n\r\n        if (reactionTrackingRef.current) {\r\n            // Great. We've already got our reaction from our render;\r\n            // all we need to do is to record that it's now mounted,\r\n            // to allow future observable changes to trigger re-renders\r\n            reactionTrackingRef.current.mounted = true\r\n            // Got a change before first mount, force an update\r\n            if (reactionTrackingRef.current.changedBeforeMount) {\r\n                reactionTrackingRef.current.changedBeforeMount = false\r\n                forceUpdate()\r\n            }\r\n        } else {\r\n            // The reaction we set up in our render has been disposed.\r\n            // This can be due to bad timings of renderings, e.g. our\r\n            // component was paused for a _very_ long time, and our\r\n            // reaction got cleaned up\r\n\r\n            // Re-create the reaction\r\n            reactionTrackingRef.current = {\r\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n                    // We've definitely already been mounted at this point\r\n                    forceUpdate()\r\n                }),\r\n                mounted: true,\r\n                changedBeforeMount: false,\r\n                cleanAt: Infinity\r\n            }\r\n            forceUpdate()\r\n        }\r\n\r\n        return () => {\r\n            reactionTrackingRef.current!.reaction.dispose()\r\n            reactionTrackingRef.current = null\r\n        }\r\n    }, [])\r\n\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    let rendering!: T\r\n    let exception\r\n    reaction.track(() => {\r\n        try {\r\n            rendering = fn()\r\n        } catch (e) {\r\n            exception = e\r\n        }\r\n    })\r\n\r\n    if (exception) {\r\n        throw exception // re-throw any exceptions caught during rendering\r\n    }\r\n\r\n    return rendering\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}